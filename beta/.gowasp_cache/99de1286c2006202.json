{
  "stage": "code_improvement",
  "file": "prompts.py",
  "prompt": "You are a Python code quality expert. Analyze the following code and provide specific, actionable improvements focusing on: security, typing.\n\nFILE: prompts.py\n\nYour analysis should cover:\n1. **Type Hints**: Add/improve type annotations (PEP 484)\n2. **Readability**: Simplify complex logic, improve naming, reduce nesting\n3. **Security**: Identify unsafe patterns (eval, exec, shell injection risks, etc.)\n4. **Performance**: Suggest more efficient approaches\n5. **Pythonic Code**: Use standard library better, follow PEP 8\n\nProvide your response in this exact JSON format. Respond ONLY with the JSON object.\n{\n  \"overall_quality\": \"EXCELLENT|GOOD|FAIR|NEEDS_IMPROVEMENT\",\n  \"improvements\": [\n    {\n      \"category\": \"typing|readability|security|performance|pythonic\",\n      \"line_number\": 42,\n      \"current_code\": \"The problematic code snippet\",\n      \"improved_code\": \"The improved version\",\n      \"explanation\": \"Why this is better\",\n      \"impact\": \"HIGH|MEDIUM|LOW\"\n    }\n  ],\n  \"summary\": \"Brief overall assessment and key recommendations\"\n}\n\nCODE TO ANALYZE:\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCentralized prompt builders for SmartAnalyzer.\nKeeping prompts separate makes the core pipeline lighter and easier to maintain.\n\"\"\"\n\nfrom __future__ import annotations\nimport json as _json\nfrom pathlib import Path\nfrom typing import List, Any\n\n\nclass PromptFactory:\n    \"\"\"Generates dynamic prompts for each stage of the analysis.\"\"\"\n\n    @staticmethod\n    def prioritization(all_files: List[Path], question: str, limit: int) -> str:\n        filenames = [f.name for f in all_files]\n        return f\"\"\"You are a lead software architect. Your task is to identify the most critical files to analyze to answer the user's question.\n\nUser Question: \"{question}\"\n\nFile List:\n{_json.dumps(filenames, indent=2)}\n\nReturn a JSON object with a single key \"prioritized_files\". This key should contain a list of objects, where each object has a \"file_name\" and a \"reason\" explaining its relevance. Limit the list to the top {limit} most relevant files. Your response must contain ONLY the JSON object.\nExample:\n{{\n  \"prioritized_files\": [\n    {{\n      \"file_name\": \"UserService.java\",\n      \"reason\": \"This file likely handles user creation and authentication, which is central to the user's security question.\"\n    }},\n    {{\n      \"file_name\": \"JwtUtil.java\",\n      \"reason\": \"This file probably manages JWT token generation and validation, a critical component of authorization.\"\n    }}\n  ]\n}}\"\"\"\n\n    @staticmethod\n    def deep_dive(file_path: Path, content: str, question: str) -> str:\n        \"\"\"Generic code prompt with enhanced AppSec requirements.\"\"\"\n        return f\"\"\"You are a Principal Application Security Engineer. Your analysis must be meticulous, pragmatic, and map to industry standards. Analyze the following code in the context of the user's question.\n\nFILE: {file_path}\nQUESTION: {question}\n\nProvide your analysis in this exact JSON format. Your entire response must be ONLY the JSON object.\n{{\n  \"relevance\": \"HIGH|MEDIUM|LOW|NONE\",\n  \"insights\": [\n    {{\n      \"finding\": \"A concise description of the specific security weakness.\",\n      \"impact\": \"CRITICAL|HIGH|MEDIUM|LOW\",\n      \"confidence\": \"HIGH|MEDIUM|LOW\",\n      \"effort\": \"HIGH|MEDIUM|LOW\",\n      \"line_number\": 45,\n      \"cwe\": \"CWE-ID (e.g., 'CWE-89' for SQL Injection). If not applicable or unsure, use 'N/A'.\",\n      \"recommendation\": \"A specific, actionable recommendation with a brief 'why'.\"\n    }}\n  ]\n}}\n\nCODE TO ANALYZE:\n{content}\"\"\"\n\n    @staticmethod\n    def deep_dive_yaml(file_path: Path, content: str, question: str) -> str:\n        \"\"\"Analyze Kubernetes/values YAML with security & correctness hints.\"\"\"\n        return f\"\"\"You are a Kubernetes and DevSecOps expert. Analyze the following YAML file in the context of the user's question.\nFILE: {file_path}\nQUESTION: {question}\n\nTreat this as either a Kubernetes manifest or a Helm values file. Identify security misconfigurations (e.g., missing resources, securityContext, RBAC risks, hostPath, privileged), upgrade risks, and best-practice deviations.\n\nProvide a concise analysis in THIS EXACT JSON format. Respond ONLY with the JSON object.\n{{\n  \"relevance\": \"HIGH|MEDIUM|LOW|NONE\",\n  \"detected_type\": \"k8s-manifest|helm-values|unknown\",\n  \"insights\": [\n    {{\n      \"finding\": \"Description of the issue, misconfig, or notable behavior.\",\n      \"impact\": \"CRITICAL|HIGH|MEDIUM|LOW\",\n      \"confidence\": \"HIGH|MEDIUM|LOW\",\n      \"effort\": \"HIGH|MEDIUM|LOW\",\n      \"line_number\": 1,\n      \"cwe\": \"CWE-ID (e.g., 'CWE-22'). If not applicable or unsure, use 'N/A'.\",\n      \"recommendation\": \"Specific, actionable remediation or validation.\"\n    }}\n  ]\n}}\nYAML TO ANALYZE:\n{content}\"\"\"\n\n    @staticmethod\n    def deep_dive_helm(file_path: Path, content: str, question: str) -> str:\n        \"\"\"Analyze Helm templates (.tpl/.gotmpl or templates/*.yaml) safely.\"\"\"\n        return f\"\"\"You are a Helm + Kubernetes expert. Analyze this Helm template in the context of the user's question.\nFILE: {file_path}\nQUESTION: {question}\n\nConsider Go templating, values usage, and Kubernetes schema validity. Point out anti-patterns (hard-coded images, insecure securityContext, cluster-admin RBAC, NodePort exposure, hostPath, etc.) and Helm upgrade pitfalls (immutable fields).\n\nProvide a concise analysis in THIS EXACT JSON format. Respond ONLY with the JSON object.\n{{\n  \"relevance\": \"HIGH|MEDIUM|LOW|NONE\",\n  \"detected_type\": \"helm-template\",\n  \"insights\": [\n    {{\n      \"finding\": \"Specific template or values misuse, security issue, or upgrade pitfall.\",\n      \"impact\": \"CRITICAL|HIGH|MEDIUM|LOW\",\n      \"confidence\": \"HIGH|MEDIUM|LOW\",\n      \"effort\": \"HIGH|MEDIUM|LOW\",\n      \"line_number\": 1,\n      \"cwe\": \"CWE-ID. If not applicable or unsure, use 'N/A'.\",\n      \"recommendation\": \"Action to fix or validate.\"\n    }}\n  ]\n}}\nHELM TEMPLATE TO ANALYZE:\n{content}\"\"\"\n    \n    @staticmethod\n    def annotation(finding: Any, code_content: str) -> str:\n        \"\"\"Generates a focused, annotated code snippet for a specific finding.\"\"\"\n        return f\"\"\"You are a secure coding expert providing feedback in a code review. Your task is to create an annotated code snippet for a specific security finding.\n\nSECURITY FINDING:\n- File: {finding.file_path}\n- Line: {finding.line_number}\n- Description: {finding.finding}\n- Recommendation: {finding.recommendation}\n\nFULL CODE CONTENT:\n{code_content}\n\nINSTRUCTIONS:\n1.  Extract a code snippet of 10-15 lines centered around the vulnerable line ({finding.line_number}).\n2.  Add a comment directly above the vulnerable line: `// FLAW: [Brief summary of the flaw]`\n3.  Add a comment block directly below the vulnerable line showing the corrected code: `// FIX: \\n// [Corrected code line(s)]`\n\nProvide your response in a single, clean JSON object with one key, \"annotated_snippet\". Do not include any text outside the JSON.\nExample format:\n{{\n  \"annotated_snippet\": \"public void insecureMethod(String userInput) {{\\\\n    // ... some code ...\\\\n    // FLAW: This line is vulnerable to SQL Injection.\\\\n    Statement stmt = conn.createStatement();\\\\n    ResultSet rs = stmt.executeQuery(\\\\\"SELECT * FROM users WHERE name = '\\\" + userInput + \\\"'\\\\\");\\\\n    // FIX:\\\\n    // PreparedStatement ps = conn.prepareStatement(\\\\\"SELECT * FROM users WHERE name = ?\\\\\");\\\\n    // ps.setString(1, userInput);\\\\n    // ResultSet rs = ps.executeQuery();\\\\n    // ... more code ...\\\\n}}\"\n}}\"\"\"\n\n    @staticmethod\n    def synthesis(all_findings: list, question: str) -> str:\n        \"\"\"Generate the executive summary based on findings and question.\"\"\"\n        from pathlib import Path as _Path\n        condensed_findings = [f\"- {f.finding} (in {_Path(f.file_path).name})\" for f in all_findings]\n        \n        synthesis_goal = \"\"\"Your report must be in Markdown and contain the following three sections EXACTLY:\n\n1.  **Executive Summary:** A one-paragraph, high-level overview for a non-technical manager. Explain the overall state of the codebase regarding the user's question and the primary business risk.\n\n2.  **Key Patterns & Root Causes:** Instead of just listing findings, group them. Identify 2-4 overarching *patterns* or *root causes*. For example, \"Systemic Lack of Input Validation\" or \"Inconsistent Error Handling.\" Explain why these patterns are problematic.\n\n3.  **Prioritized Action Plan:** Provide a numbered list of concrete steps for the development team. Start with the highest-impact, lowest-effort items. Each step should reference the files involved.\"\"\"\n\n        return f\"\"\"You are a principal software architect tasked with creating a strategic report. Based on the user's original question and a list of raw findings, generate a high-level action plan.\n{synthesis_goal}\n\nOriginal Question: \"{question}\"\n\nRaw Findings:\n{chr(10).join(condensed_findings)}\"\"\"\n\n    @staticmethod\n    def payload_generation(finding: Any, code_snippet: str) -> str:\n        \"\"\"Generate safe, educational payloads for verification and defense.\"\"\"\n        return f\"\"\"You are a security testing expert. For the following vulnerability finding, generate example payloads for both offensive verification (Red Team) and defensive testing (Blue Team). This is for authorized, educational purposes only.\n\nVULNERABILITY CONTEXT:\nFile: {finding.file_path}\nLine: {finding.line_number}\nFinding: {finding.finding}\n\nCODE SNIPPET:\n{code_snippet}\n\nTASK:\nProvide your response in a single, clean JSON object with the following structure. Do not include any text outside the JSON.\n{{\n  \"red_team_payload\": {{\n    \"payload\": \"A simple, non-destructive payload to verify the flaw's existence.\",\n    \"explanation\": \"A brief explanation of why this payload works for verification.\"\n  }},\n  \"blue_team_payload\": {{\n    \"payload\": \"A payload that can be used in a unit test or WAF rule to test the fix.\",\n    \"explanation\": \"A brief explanation of how this payload helps test the defensive measure.\"\n  }}\n}}\"\"\"\n\n    @staticmethod\n    def code_improvement(file_path: Path, content: str, focus_areas: List[str]) -> str:\n        \"\"\"Generate suggestions to improve Python code quality.\"\"\"\n        focus_str = \", \".join(focus_areas) if focus_areas else \"all aspects\"\n        \n        return f\"\"\"You are a Python code quality expert. Analyze the following code and provide specific, actionable improvements focusing on: {focus_str}.\n\nFILE: {file_path}\n\nYour analysis should cover:\n1. **Type Hints**: Add/improve type annotations (PEP 484)\n2. **Readability**: Simplify complex logic, improve naming, reduce nesting\n3. **Security**: Identify unsafe patterns (eval, exec, shell injection risks, etc.)\n4. **Performance**: Suggest more efficient approaches\n5. **Pythonic Code**: Use standard library better, follow PEP 8\n\nProvide your response in this exact JSON format. Respond ONLY with the JSON object.\n{{\n  \"overall_quality\": \"EXCELLENT|GOOD|FAIR|NEEDS_IMPROVEMENT\",\n  \"improvements\": [\n    {{\n      \"category\": \"typing|readability|security|performance|pythonic\",\n      \"line_number\": 42,\n      \"current_code\": \"The problematic code snippet\",\n      \"improved_code\": \"The improved version\",\n      \"explanation\": \"Why this is better\",\n      \"impact\": \"HIGH|MEDIUM|LOW\"\n    }}\n  ],\n  \"summary\": \"Brief overall assessment and key recommendations\"\n}}\n\nCODE TO ANALYZE:\n{content}\"\"\"\n",
  "raw_response": "{\n    \"overall_quality\": \"GOOD\",\n    \"improvements\": [\n        {\n            \"category\": \"typing\",\n            \"line_number\": null,\n            \"current_code\": \"finding: Any\",\n            \"improved_code\": \"finding: Union[Finding, Dict[str, Any]]\",\n            \"explanation\": \"Replace generic 'Any' type with a more specific type hint to improve type safety\",\n            \"impact\": \"MEDIUM\"\n        },\n        {\n            \"category\": \"readability\",\n            \"line_number\": 84,\n            \"current_code\": \"chr(10).join(condensed_findings)\",\n            \"improved_code\": \"'\\n'.join(condensed_findings)\",\n            \"explanation\": \"Use more readable '\\n' newline character instead of chr(10)\",\n            \"impact\": \"LOW\"\n        },\n        {\n            \"category\": \"security\",\n            \"line_number\": null,\n            \"current_code\": \"f\\\"FILE: {file_path}\\\"\",\n            \"improved_code\": \"f\\\"FILE: {file_path.name}\\\"\",\n            \"explanation\": \"Use .name to prevent potential path traversal by exposing full file path\",\n            \"impact\": \"MEDIUM\"\n        },\n        {\n            \"category\": \"pythonic\",\n            \"line_number\": null,\n            \"current_code\": \"from __future__ import annotations\",\n            \"improved_code\": \"from __future__ import annotations\\nfrom typing import Union, Dict, Optional\",\n            \"explanation\": \"Add specific imports for more precise type hinting\",\n            \"impact\": \"LOW\"\n        }\n    ],\n    \"summary\": \"The PromptFactory class is well-structured and follows good practices. Primary recommendations include improving type hints, using more Pythonic string handling, and adding defensive path handling. The static method design allows for clean, focused prompt generation across different contexts.\"\n}",
  "parsed": {
    "overall_quality": "GOOD",
    "improvements": [
      {
        "category": "typing",
        "line_number": null,
        "current_code": "finding: Any",
        "improved_code": "finding: Union[Finding, Dict[str, Any]]",
        "explanation": "Replace generic 'Any' type with a more specific type hint to improve type safety",
        "impact": "MEDIUM"
      },
      {
        "category": "readability",
        "line_number": 84,
        "current_code": "chr(10).join(condensed_findings)",
        "improved_code": "'\n'.join(condensed_findings)",
        "explanation": "Use more readable '\n' newline character instead of chr(10)",
        "impact": "LOW"
      },
      {
        "category": "security",
        "line_number": null,
        "current_code": "f\"FILE: {file_path}\"",
        "improved_code": "f\"FILE: {file_path.name}\"",
        "explanation": "Use .name to prevent potential path traversal by exposing full file path",
        "impact": "MEDIUM"
      },
      {
        "category": "pythonic",
        "line_number": null,
        "current_code": "from __future__ import annotations",
        "improved_code": "from __future__ import annotations\nfrom typing import Union, Dict, Optional",
        "explanation": "Add specific imports for more precise type hinting",
        "impact": "LOW"
      }
    ],
    "summary": "The PromptFactory class is well-structured and follows good practices. Primary recommendations include improving type hints, using more Pythonic string handling, and adding defensive path handling. The static method design allows for clean, focused prompt generation across different contexts."
  },
  "timestamp": "2025-10-31T03:58:43.646584+00:00"
}